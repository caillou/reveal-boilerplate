section
    h1 Webpack
    h3 The cool kids' Javascript bundler

section
    h2 Agenda
    ul
        li Why do we need bundlers and what should they be capable of?
        li Review of the main competitors of Webpack
        li What can Webpack do what the other bundlers cannot?

section
    h2 About me

    h5 Name
    p Reto SchlÃ¤pfer

    h5 Work
    p React.js/Flux & Finance related backend stuff in Python at #[i Bluevalor AG]

    h5 Blog
    p www.code-experience.com

    h5 Twitter
    p: i @Retolements

    h5 GitHub
    p: i Retozi


section
    h2 Why do we need a bundler?

    div.fragment
        p Because modules should be small, and loading many modules through HTTP-Requests is slow.

        p Bundling modules reduces the amount of necessary HTTP-Requests to load our app.



section
    h2 Requirements of a good bundler


section
    h2 For production

    p Enable you the choose a bundling strategy so that your app loads quickly:

    p Deliver modules that are needed at the same time in one HTTP-Request.

    p Deliver independent modules seperately.

    p optimize size of bundles.


section
    h2 For Development

    p Deliver changes to modules instantly


section
    h2 RequireJS vs Browserify


section
    h2 RequireJS

    p AMD style modules

    pre
        code.hljs.javascript.
            define([
              'jquery',
              'underscore',
              'backbone',
              'router',
            ], function($, _, Backbone, Router){
              var initialize = function(){
                Router.initialize();
              }

              return {
                initialize: initialize
              };
            });

section
    h2 RequireJS: The Good

    p Battle proven

    p Allows for flexible asynchronous loading if needed

section
    h2 RequireJS: The Bad

    p AMD is out, CommonJS is in (npm EVERYTHING)

    p A lot is possible, but everything requires massive configuration


section
    h2 Browserify

    p CommonJS module style

    pre
        code.hjs.javascript.

            var $ = require('jquery');
            var _ = require('lodash');
            var backbone = require('backbone');
            var router = require('Router');

              var initialize = function(){
                Router.initialize();
              }

            module.exports = initialize;

section

    h2 Browserify: The Good

    p Use npm / node.js libraries

    p.
        Integrates seamlessly with Gulp/Grunt.
        This allows for powerful processing strategies.

    p CommonJS syntax is better



section
    h2 Browserify: The Bad

    p you need Gulp/Grunt and plugins for instant dev rebuilds.

    p.
        Default is bundling into a single file. Async loading & multiple bundles
        possible, but it must be done manually.


section

    h2 Conclusion

    p Internet Consensus: Browserify > RequireJS for most of the cases


section

    h2 Webpack

    p Instagram/Facebook hypes it, Yahoo uses it as well.


section

    h2 Everything is a module

    p Why do other bundlers only care about Javascript modules?

    p There are other assets that need bundling!


section(data-state="white-background")

    p Take the full dependency graph of all assets, and bundle them to your liking

    img(src="/presentations/webpack/what-is-webpack.png")


section

    h2 Bundling everything into one file is often not enough

    p.
        If our app is big, you would like to split the assets into multiple chunks:

    ul
        li single out vendor libs ("common chunk")
        li provide only modules needed for given entrypoint
        li load rarely used libs on demand


section

    h2 Why do I have to refresh my browser in development?

    p.
        Weback ships awesome devtools that provide instant rebuilds with
        hot reload.


section

    h2 How to use Webpack
    pre
        code.hjs.javascript.
            // ------------------
            // webpack.config.js
            // ------------------

            module.exports = {
                entry: ['./src/app.js'],
                output: {
                    path: __dirname + '/build/js',
                    filename: 'bundle.js',
                    publicPath: '/js/'
                }
            };

section

    h2 How the hell do I bundle pngs and css?


    pre
        code.hljs.javascript.

            //yes, we require sass!
            require('./mySassForThisModule.scss');

            var _ = require('lodash');
            var FooComponent = require('./FooComponent.jsx');

            //yes, we require png!
            var imageLink = require('../../img/myImage.png');

            // do something with imageLink, FooComponent and lodash

            module.exports = ThisModule;

    p.
        If you bundle this with webpack, all the assets will be automagically
        available when you include your bundle into your html document.


section

    h2 Loaders

    blockquote(cite="http://webpack.github.io/docs/loaders.html").
        Loaders are transformations that are applied on files. They preprocess files.
        For instance they can transform CoffeeScript to JavaScript.


section

    h2 Lots of Loaders (via npm)
    ul
        li inlining stylesheets
        li various preprocessors (jsx, CoffeeScript, es6)
        li templates
        li files, jsons, source-maps
        li promises, webworkers


section

    h2 Loader Configuration

    pre
        code.hljs.javascript.
            // ------------------
            // webpack.config.js
            // ------------------
            ...,
            module: {
                loaders: [
                    {
                        test: /\.js.{0,1}$/,
                        loader: 'jsx?harmony'
                    },{
                        test: /\.scss$/,
                        loader: "style!css!sass?outputStyle=expanded&includePaths[]=" + __dirname + '/src/scss'
                    }, {
                        test: /\.css$/,
                        loader: "style!css"
                    }
                ],
            },
            ...


section

    h2 Loaders are awesome

    p requiring and inlining stylesheets is super helpful.

    p you get all the freedom you need with preprocessors.

    p you can do cool stuff like inlining small pngs or json files.


section

    h2 So your project is big...


section

    h2 Load on Demand

    p Create splitpoints

    pre
        code.hljs.javascript.

            require.ensure(["./otherPart.js"], function (otherPart) {
                // now you can use otherPart
            });

    p.
        This will create two files (called chunks by Webpack).
        One is your entrypoint, the other gets loaded on demand.


section

    h2 Multiple Entrypoints

    p Run the CommonsChunkPlugin to split code up

    pre
        code.hljs.javascript.
            {
                entry: { a: "./a", b: "./b" },
                output: { filename: "[name].js" },
                plugins: [ new webpack.CommonsChunkPlugin("common.js") ]
            }


section

    h2 Caching

    p Add hashes to your filenames

    pre
        code.hljs.javascript.
            output: {
                path: path.join(__dirname, "assets", "[hash]"),
                publicPath: "assets/[hash]/",
                filename: "output.[hash].bundle.js",
                chunkFilename: "[id].[hash].bundle.js"
            }


section

    h2 There is more

    ul
        li uglify
        li dedupe
        li various chunk optimizations (max chunk count, min chunk size)
        li gulp/grunt
        li target various runtimes


section

    h2 Development productivity


section

    h2 webpack-dev-server

    p Incremental (=instant) rebuilds

    p hot reload without plugins


section

    h2 dev-server setup

    pre
        code.hljs.javascript.
            "use strict";
            var webpack = require('webpack');
            var WebpackDevServer = require('webpack-dev-server');
            var config = require('./webpack.config');

            var server = new WebpackDevServer(webpack(config), {
                // webpack-dev-server options
                hot: true,
                contentBase: __dirname,
                quiet: false,
                noInfo: false,
                publicPath: '/js/',
                stats: { colors: true }
            });

            server.listen(8081, "localhost", function() {});
